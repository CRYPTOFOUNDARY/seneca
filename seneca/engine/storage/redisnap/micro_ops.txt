"""
Smaller operations that combined can describe RESP commands
"""
from abc import ABCMeta, abstractmethod
from typing import Union

from seneca.engine.util import auto_set_fields

# TODO: must pick a behavior based on address type.
# TODO: probably want a field on all MicroOps called required ops. May want to rename MicroOps to just Ops

def run_incr_with_type_check(addr, ex):
    type_matches, _ = ex(DeepTypeCheckMicroOP(addr, RScalarInt))
    assert(type_matches)
    return ex(IncrByMicroOP(self.addr, amount))


class MicroOp(metaclass=ABCMeta):
    """
    MicroOps:
    * Used to describe the steps taken when RESP commands.
    * Redisnap local backend uses command objects to generate these ops, then
    it runs them.
    * Used to figure out dependencies.
    * Must be runnable by redis_backend for commands that fallthrough the save
    point stack
    * But, not the prefered way to run commands on the Redis backend.
    Redis (of course) has its own modeling of how RESP commands break down into
    more basic operations.
    """
    def __repr__(self):
        return '<RESP MicroOP (%s) %s>' % (self.__class__.__name__, str(self.__dict__))

    @abstractmethod
    def run_as_commands(self, ex):
        """
        This function is needed because the Redis backend doesn't know how to
        execute micro-ops, only commands. As micro-ops fallthrough the savepoint
        stack, they may need to be executed on Redis, in that case they must be
        converted to commands. This is the crux of why micro-ops exist in this
        system: Redis commands are not granular enough, some functionalities of
        the commands need to selectively fall through the savepoint stack.
        """
        raise NotImplementedError()


class ShallowTypeCheckMicroOP(MicroOp):
    @auto_set_fields
    def __init__(self, addr):
        """
        Type checking is unique in Redis, because empty addresses are fully
        polymorphic, so it passes on correct type or on does not exist.
        """
        pass

    def run_as_commands(self, ex):
        return ex(Type(self.addr.base_address()))


class DeepTypeCheckMicroOP(MicroOp):
    @auto_set_fields
    def __init__(self, addr, exact_expected_type):
        """
        Type checking is unique in Redis, because empty addresses are fully
        polymorphic, so it passes on correct type or on does not exist.
        """
        pass

    def run_as_commands(self, ex):
        pass


class ReadMicroOP(MicroOp):
    @auto_set_fields
    def __init__(self, addr):
        pass

    def run_as_commands(self, ex):
        addr_types_to_commands = {
            ScalarAddress: Get
            RHashAddress:
            RHashFieldAddress:
        }




        pass





class WriteMicroOP(MicroOp):
    @auto_set_fields
    def __init__(self, addr, payload):
        pass

    def run_as_commands(self, ex):
        pass


class IncrByMicroOP(MicroOp):
    # TODO: Must always do type check
    @auto_set_fields
    def __init__(self, addr, payload):
        pass

    def run_as_commands(self, ex):
        pass


# TODO: Make macro ops
class AppendMicroOP(MicroOp):
    # TODO: Must always do type check
    @auto_set_fields
    def __init__(self, addr, payload):
        pass

    def run_as_commands(self, ex):
        pass

# NOTE: It would be possible to add more granular operations like check-exists,
# but write now CHECK will just map to ReadMicroOP
