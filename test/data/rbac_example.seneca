from seneca.storage.tabular import create_table, get_table, str_len, add_column, drop_column, drop_table
import seneca.runtime.state as st
from seneca.modulelib import export, auto_exports

# TODO: Implement per-table permissions

# Table definitions
users = create_table('users', [
    ('user', str_len(50), True),
    ('role', str_len(30)),
])
roles = create_table('roles', [
    ('role', str_len(30), True),
    ('create_table', bool),
    ('drop_table', bool),
    ('edit_users', bool),
    ('edit_roles', bool),
    ('edit_data', bool),
])


def _insert_role(name, create_table, drop_table, edit_users, edit_roles, edit_data):
    roles.insert([{
        'role': name,
        'create_table': create_table,
        'drop_table': drop_table,
        'edit_users': edit_users,
        'edit_roles': edit_roles,
        'edit_data': edit_data,
    }]).run()


def _insert_user(user_pub_key, role_name):
    # Verify role exists
    q = roles.select().where_equals('role', role_name)
    assert len(q.run() > 0), "ERROR: role not found"

    users.insert([{
        'user': user_pub_key,
        'role': role_name,
    }]).run()


def assert_has_perm(perm_name):
    # Find role for current user
    r_name = users.select().where_equals('user', st.user).run()[0]['role']
    # Find and return boolean value for the specified permission in that role
    is_allowed = roles.select().where_equals('role', r_name).run()[0][perm_name]
    assert is_allowed, "ERROR: The current user does not have the necessary permission."


def assert_not_protected_table(t_name):
    assert t_name not in ['roles', 'users'], 'ERROR: You have attempted to access a protected table. \
      there are dedicated functions to do that. Access denied.'


# Note: read functions are solely for convenience/completeness, tables are world readable
@export
def create_role(*args):
    assert_has_perm('edit_roles')
    return _insert_role(*args)


@export
def delete_role(r):
    assert_has_perm('edit_roles')
    return roles.delete.where_equals('role', r).run()


@export
def update_role(name, create_table, drop_table, edit_users, edit_roles, edit_data):
    assert_has_perm('edit_roles')
    return roles.update.where_equals('role', name).([{
        'create_table': create_table,
        'drop_table': drop_table,
        'edit_users': edit_users,
        'edit_roles': edit_roles,
        'edit_data': edit_data,
    }]).run()


@export
def read_role(r):
    return roles.select.where_equals('role', r).run()[0]


@export
def create_user(*args):
    assert_has_perm('edit_users')
    return _insert_user(*args)


@export
def delete_user(u_name):
    assert_has_perm('edit_users')
    return users.delete.where_equals('user', u_name).run()


@export
def update_user(u, r):
    assert_has_perm('edit_users')
    return users.update({'role': r}).where_equals('user', u).run()


@export
def read_user(u):
    return users.select.where_equals('user', u).run()[0]
    

@export
def create_table(t_name, t_def):
    assert_has_perm('create_table')
    assert_not_protected_table(t_name)

    return create_table(t_name, t_def)


@export
def delete_table(t_name):
    assert_has_perm('drop_table')
    assert_not_protected_table(t_name)
    return drop_table(t_name)


@export
def create_row(t_name, row_data):
    assert_has_perm('edit_data')
    assert_not_protected_table(t_name)
    t = get_table(t_name)
    t.insert(row_data).run()


@export
def update_row(t_name, row_data):
    assert_has_perm('edit_data')
    assert_not_protected_table(t_name)
    assert 'id' in row_data, "An id must be included for updates"

    t = get_table(t_name)
    return t.update(row_data).where_equals('id', row_data['id']).run()
   

@export
def read_row(t_name, r_id):
    t = get_table(t_name)
    return t.select.where_equals('id', r_id).run()[0]
 

if __name__ == '__main__':
    # Create first user, the author of this contract, and give that user admin perms
    _insert_role('admin', True, True, True, True, True)
    _insert_user(st.user, 'admin')
else:
    exports = auto_export()







