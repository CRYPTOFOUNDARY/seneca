#!/usr/bin/env seneca_0.1

## Example currency smart contract ##

# seneca lib is always present for import
from seneca.storage import redis as st
from seneca.std_lib.functools import partial
from seneca import crypto
from seneca.runtime import state as rt_state


def get_balance(ledger, wallet_id):
    return ledger.select('balance').where(wallet_id=wallet_id).run()[0]


def wallet_exists(ledger, wallet_id):
    return bool(ledger.select('wallet_id').where(wallet_id=wallet_id).run())


def create_wallet(ledger, wallet_id):
    assert not wallet_exists(ledger, wallet_id), "Wallet already exists"
    ledger.insert(wallet_id=wallet_id, balance=0)


def add_coins(ledger, wallet_id, amount_to_add):
    assert wallet_exists(wallet_id), "Wallet id is not present in ledger"
    assert amount_to_add >= 0, "It's not possible to 'add' a negative balance"

    old_balance = get_balance(wallet_id)
    ledger.update(balance=old_balance + amount_to_add) \
          .where(wallet_id=wallet_id).run()


def remove_coins(ledger, wallet_id, amount_to_remove):
    assert wallet_exists(wallet_id), "Wallet id is not present in ledger"
    assert amount_to_remove >= 0, "Removing negative balances not permitted"

    old_balance = get_balance(wallet_id)
    assert old_balance - amount_to_remove >= 0, "No negative balances allowed"


def transfer_coins(ledger, sender_id, receiver_id, amount):
    remove_coins(ledger, sender_id, amount)
    add_coins(ledger, receiver_id, amount)


# We use Seneca's custom export/import functions because:
# * Python doesn't have built in support for private functions.
# * We need to import contracts from the blockchain, not the file system.
if __name__ == '__main__':
    # The smart contract is being run directly for the first (and only) time.

    # Establish a storage space
    ledger = st.table.create('ledger', {
      'wallet_id': st.column(Integer, unique=True),
      'balance': st.column(Integer),
    })

    primordial_account = \
      crypto.base64.b64decode('IAHpAaIsqZtqbWmreNFcg1aifxaawQXIWyaA39Lx8bfKgPpb')

    monetary_base = 10 ** 10

    create_wallet(ledger, primordial_account)
    add_coins(ledger, primordial_account, monetary_base)

else:
    ledger = st.table.get('ledger')

    # Important: The add/remove/transfer functions above are not safe to
    # export. They don't do any access control checks, so we wrap transfer_coins
    # with that logic.
    def safe_transfer_coins(ledger, sender_id, receiver_id, amount):
        # Limit module call depth to make access control checks simple.
        assert len(rt_state.call_chain) == 1, \
          "If this contract is imported, it must be called directly from the \
            __main__ contract"

        # Get the caller signature
        caller_pubkey = rt_state.call_chain[0].public_key

        assert wallet_id == caller_pubkey, "ACCESS DENIED! \
          Only the sender may iniate transfers!"

        # If access control checks pass, run the transfer_coins function
        return transfer_coins(ledger, sender_id, receiver_id, amount)


    # The smart contract is being imported by another smart contract.
    # Only exports the following:
    return map(lambda f: partial(f, ledger), [
        get_balance,
        wallet_exists,
        safe_transfer_coins,
        create_wallet,
    ])
